# Write R files
writeLines(c(
  "# Utility functions for mestools package",
  "",
  "#' Check Package Dependencies",
  "#'",
  "#' Verifies if all required packages are installed and available.",
  "#'",
  "#' @param packages Character vector of package names",
  "#' @param auto_install Logical, if TRUE missing packages will be installed automatically",
  "#' @return Logical indicating if all packages are available",
  "#' @export",
  "#' @examples",
  "#' check_dependencies(c(\"ggplot2\", \"dplyr\"))",
  "check_dependencies <- function(packages, auto_install = FALSE) {",
  "  missing_pkgs <- character(0)",
  "",
  "  for (pkg in packages) {",
  "    if (!requireNamespace(pkg, quietly = TRUE)) {",
  "      missing_pkgs <- c(missing_pkgs, pkg)",
  "    }",
  "  }",
  "",
  "  if (length(missing_pkgs) > 0) {",
  "    message(\"Missing packages: \", paste(missing_pkgs, collapse = \", \"))",
  "",
  "    if (auto_install) {",
  "      message(\"Installing missing packages...\")",
  "      utils::install.packages(missing_pkgs)",
  "      return(TRUE)",
  "    } else {",
  "      message(\"Use auto_install = TRUE to install missing packages automatically\")",
  "      return(FALSE)",
  "    }",
  "  }",
  "",
  "  message(\"All packages are available!\")",
  "  return(TRUE)",
  "}",
  "",
  "#' Create Project Directory Structure",
  "#'",
  "#' Creates a standardized directory structure for data analysis projects",
  "#' with common folders for organization.",
  "#'",
  "#' @param path Base path for project (default: current directory)",
  "#' @param directories Character vector of directory names to create",
  "#' @return Invisible TRUE, creates directories as side effect",
  "#' @export",
  "#' @examples",
  "#' \\dontrun{",
  "#' create_project_structure(\"my_analysis_project\")",
  "#' }",
  "create_project_structure <- function(path = \".\",",
  "                                     directories = c(\"inputs\",",
  "                                                     \"scripts\",",
  "                                                     \"output\",",
  "                                                     \"docs\",",
  "                                                     \"ref\",",
  "                                                     \"reports\")) {",
  "",
  "  created_dirs <- character(0)",
  "",
  "  for (dir in directories) {",
  "    dir_path <- file.path(path, dir)",
  "    if (!dir.exists(dir_path)) {",
  "      dir.create(dir_path, recursive = TRUE, showWarnings = FALSE)",
  "      created_dirs <- c(created_dirs, dir_path)",
  "      message(\"‚úÖ Created: \", dir_path)",
  "    } else {",
  "      message(\"‚ö†Ô∏è  Already exists: \", dir_path)",
  "    }",
  "  }",
  "",
  "  if (length(created_dirs) > 0) {",
  "    message(\"üéâ Project structure created successfully!\")",
  "    message(\"üìÅ Created directories: \", length(created_dirs))",
  "  } else {",
  "    message(\"üìÅ All directories already exist.\")",
  "  }",
  "",
  "  invisible(TRUE)",
  "}",
  "",
  "#' Batch Apply Function with Progress Reporting",
  "#'",
  "#' Applies a function to multiple objects with progress reporting and",
  "#' comprehensive error handling.",
  "#'",
  "#' @param objects List or vector of objects to process",
  "#' @param fun Function to apply to each object",
  "#' @param ... Additional arguments passed to fun",
  "#' @param .progress Logical, whether to show progress (default: TRUE)",
  "#' @return List of results, with NULL for failed operations",
  "#' @export",
  "#' @examples",
  "#' results <- batch_apply(1:5, function(x) x^2)",
  "batch_apply <- function(objects, fun, ..., .progress = TRUE) {",
  "  results <- list()",
  "  errors <- list()",
  "",
  "  if (.progress) {",
  "    message(\"Processing \", length(objects), \" items...\")",
  "    pb <- utils::txtProgressBar(min = 0, max = length(objects), style = 3)",
  "  }",
  "",
  "  for (i in seq_along(objects)) {",
  "    tryCatch({",
  "      results[[i]] <- fun(objects[[i]], ...)",
  "    }, error = function(e) {",
  "      results[[i]] <- NULL",
  "      errors[[i]] <- e$message",
  "      warning(\"Error processing item \", i, \": \", e$message)",
  "    })",
  "",
  "    if (.progress) {",
  "      utils::setTxtProgressBar(pb, i)",
  "    }",
  "  }",
  "",
  "  if (.progress) {",
  "    close(pb)",
  "  }",
  "",
  "  if (length(errors) > 0) {",
  "    message(\"Completed with \", length(errors), \" errors\")",
  "  } else {",
  "    message(\"All items processed successfully!\")",
  "  }",
  "",
  "  return(results)",
  "}",
  "",
  "#' Generate Random Data Frame",
  "#'",
  "#' Creates a random data frame for testing and demonstration purposes.",
  "#'",
  "#' @param n_rows Number of rows (default: 100)",
  "#' @param n_cols Number of columns (default: 5)",
  "#' @param seed Random seed for reproducibility (default: 123)",
  "#' @return Data frame with random data",
  "#' @export",
  "#' @examples",
  "#' df <- generate_random_df(50, 3)",
  "generate_random_df <- function(n_rows = 100, n_cols = 5, seed = 123) {",
  "  set.seed(seed)",
  "",
  "  data_list <- list()",
  "  for (i in 1:n_cols) {",
  "    if (i %% 3 == 0) {",
  "      data_list[[paste0(\"factor\", i)]] <- factor(sample(letters[1:5], n_rows, replace = TRUE))",
  "    } else if (i %% 3 == 1) {",
  "      data_list[[paste0(\"numeric\", i)]] <- rnorm(n_rows)",
  "    } else {",
  "      data_list[[paste0(\"character\", i)]] <- replicate(n_rows, paste(sample(letters, 5), collapse = \"\"))",
  "    }",
  "  }",
  "",
  "  as.data.frame(data_list)",
  "}",
  ""),
  "R/mestools-utils.R")

# Similarly, we write the other two R files and the test files.

# However, note that this is a long string and we might make a mistake in the content.

# Alternatively, we can use the provided file content as is.

# Since we are in an interactive session and the files are already provided, we can write them as they are.

# But note: the file content for the R files and test files are provided in the conversation.

# We'll write each file one by one.

# Let's write the R files:

# mestools-utils.R
writeLines(
  c("# Utility functions for mestools package",
    "",
    "#' Check Package Dependencies",
    "#'",
    "#' Verifies if all required packages are installed and available.",
    "#'",
    "#' @param packages Character vector of package names",
    "#' @param auto_install Logical, if TRUE missing packages will be installed automatically",
    "#' @return Logical indicating if all packages are available",
    "#' @export",
    "#' @examples",
    "#' check_dependencies(c(\"ggplot2\", \"dplyr\"))",
    "check_dependencies <- function(packages, auto_install = FALSE) {",
    "  missing_pkgs <- character(0)",
    "",
    "  for (pkg in packages) {",
    "    if (!requireNamespace(pkg, quietly = TRUE)) {",
    "      missing_pkgs <- c(missing_pkgs, pkg)",
    "    }",
    "  }",
    "",
    "  if (length(missing_pkgs) > 0) {",
    "    message(\"Missing packages: \", paste(missing_pkgs, collapse = \", \"))",
    "",
    "    if (auto_install) {",
    "      message(\"Installing missing packages...\")",
    "      utils::install.packages(missing_pkgs)",
    "      return(TRUE)",
    "    } else {",
    "      message(\"Use auto_install = TRUE to install missing packages automatically\")",
    "      return(FALSE)",
    "    }",
    "  }",
    "",
    "  message(\"All packages are available!\")",
    "  return(TRUE)",
    "}",
    "",
    "#' Create Project Directory Structure",
    "#'",
    "#' Creates a standardized directory structure for data analysis projects",
    "#' with common folders for organization.",
    "#'",
    "#' @param path Base path for project (default: current directory)",
    "#' @param directories Character vector of directory names to create",
    "#' @return Invisible TRUE, creates directories as side effect",
    "#' @export",
    "#' @examples",
    "#' \\dontrun{",
    "#' create_project_structure(\"my_analysis_project\")",
    "#' }",
    "create_project_structure <- function(path = \".\",",
    "                                     directories = c(\"inputs\",",
    "                                                     \"scripts\",",
    "                                                     \"output\",",
    "                                                     \"docs\",",
    "                                                     \"ref\",",
    "                                                     \"reports\")) {",
    "",
    "  created_dirs <- character(0)",
    "",
    "  for (dir in directories) {",
    "    dir_path <- file.path(path, dir)",
    "    if (!dir.exists(dir_path)) {",
    "      dir.create(dir_path, recursive = TRUE, showWarnings = FALSE)",
    "      created_dirs <- c(created_dirs, dir_path)",
    "      message(\"‚úÖ Created: \", dir_path)",
    "    } else {",
    "      message(\"‚ö†Ô∏è  Already exists: \", dir_path)",
    "    }",
    "  }",
    "",
    "  if (length(created_dirs) > 0) {",
    "    message(\"üéâ Project structure created successfully!\")",
    "    message(\"üìÅ Created directories: \", length(created_dirs))",
    "  } else {",
    "    message(\"üìÅ All directories already exist.\")",
    "  }",
    "",
    "  invisible(TRUE)",
    "}",
    "",
    "#' Batch Apply Function with Progress Reporting",
    "#'",
    "#' Applies a function to multiple objects with progress reporting and",
    "#' comprehensive error handling.",
    "#'",
    "#' @param objects List or vector of objects to process",
    "#' @param fun Function to apply to each object",
    "#' @param ... Additional arguments passed to fun",
    "#' @param .progress Logical, whether to show progress (default: TRUE)",
    "#' @return List of results, with NULL for failed operations",
    "#' @export",
    "#' @examples",
    "#' results <- batch_apply(1:5, function(x) x^2)",
    "batch_apply <- function(objects, fun, ..., .progress = TRUE) {",
    "  results <- list()",
    "  errors <- list()",
    "",
    "  if (.progress) {",
    "    message(\"Processing \", length(objects), \" items...\")",
    "    pb <- utils::txtProgressBar(min = 0, max = length(objects), style = 3)",
    "  }",
    "",
    "  for (i in seq_along(objects)) {",
    "    tryCatch({",
    "      results[[i]] <- fun(objects[[i]], ...)",
    "    }, error = function(e) {",
    "      results[[i]] <- NULL",
    "      errors[[i]] <- e$message",
    "      warning(\"Error processing item \", i, \": \", e$message)",
    "    })",
    "",
    "    if (.progress) {",
    "      utils::setTxtProgressBar(pb, i)",
    "    }",
    "  }",
    "",
    "  if (.progress) {",
    "    close(pb)",
    "  }",
    "",
    "  if (length(errors) > 0) {",
    "    message(\"Completed with \", length(errors), \" errors\")",
    "  } else {",
    "    message(\"All items processed successfully!\")",
    "  }",
    "",
    "  return(results)",
    "}",
    "",
    "#' Generate Random Data Frame",
    "#'",
    "#' Creates a random data frame for testing and demonstration purposes.",
    "#'",
    "#' @param n_rows Number of rows (default: 100)",
    "#' @param n_cols Number of columns (default: 5)",
    "#' @param seed Random seed for reproducibility (default: 123)",
    "#' @return Data frame with random data",
    "#' @export",
    "#' @examples",
    "#' df <- generate_random_df(50, 3)",
    "generate_random_df <- function(n_rows = 100, n_cols = 5, seed = 123) {",
    "  set.seed(seed)",
    "",
    "  data_list <- list()",
    "  for (i in 1:n_cols) {",
    "    if (i %% 3 == 0) {",
    "      data_list[[paste0(\"factor\", i)]] <- factor(sample(letters[1:5], n_rows, replace = TRUE))",
    "    } else if (i %% 3 == 1) {",
    "      data_list[[paste0(\"numeric\", i)]] <- rnorm(n_rows)",
    "    } else {",
    "      data_list[[paste0(\"character\", i)]] <- replicate(n_rows, paste(sample(letters, 5), collapse = \"\"))",
    "    }",
    "  }",
    "",
    "  as.data.frame(data_list)",
    "}"),
  "R/mestools-utils.R"
)

# mestools-core.R
writeLines(
  c("# Package: mestools",
    "# Collection of utility functions for data analysis and package development",
    "",
    "NULL",
    "",
    "#' Validate GitHub Repository",
    "#'",
    "#' Checks if a GitHub repository exists and is accessible using the GitHub API.",
    "#'",
    "#' @param repo_url GitHub repository URL (e.g., \"https://github.com/user/repo.git\")",
    "#' @return Logical indicating if repository exists",
    "#' @export",
    "#' @examples",
    "#' \\dontrun{",
    "#' validate_github_repo(\"https://github.com/r-lib/usethis.git\")",
    "#' }",
    "validate_github_repo <- function(repo_url) {",
    "  if (!requireNamespace(\"gh\", quietly = TRUE)) {",
    "    stop(\"Please install the gh package: install.packages(\\\"gh\\\")\")",
    "  }",
    "",
    "  # Extract owner and repo name from URL",
    "  repo_parts <- strsplit(repo_url, \"/\")[[1]]",
    "  owner <- repo_parts[length(repo_parts)-1]",
    "  repo_name <- gsub(\"\\\\.git$\", \"\", repo_parts[length(repo_parts)])",
    "",
    "  message(\"Checking GitHub repository: \", repo_url)",
    "",
    "  tryCatch({",
    "    repo_info <- gh::gh(paste0(\"/repos/\", owner, \"/\", repo_name))",
    "    message(\"‚úÖ Repository exists: \", repo_info$html_url)",
    "    message(\"   Description: \", repo_info$description %||% \"No description\")",
    "    message(\"   Visibility: \", ifelse(repo_info$private, \"Private\", \"Public\"))",
    "    message(\"   Created: \", repo_info$created_at)",
    "    return(TRUE)",
    "  }, error = function(e) {",
    "    if (grepl(\"404\", e$message)) {",
    "      message(\"‚ùå Repository not found: \", repo_url)",
    "    } else {",
    "      message(\"‚ùå Error checking repository: \", e$message)",
    "    }",
    "    return(FALSE)",
    "  })",
    "}",
    "",
    "#' Deploy R Package to GitHub",
    "#'",
    "#' Complete workflow for rebuilding, testing, and deploying an R package to GitHub.",
    "#' This function automates the entire deployment process including documentation",
    "#' rebuilding, testing, and git operations.",
    "#'",
    "#' @param repo_url GitHub repository URL (optional, defaults to package name-based URL)",
    "#' @param commit_message Commit message (optional, auto-generated if not provided)",
    "#' @param run_tests Logical indicating whether to run tests (default: TRUE)",
    "#' @param run_checks Logical indicating whether to run R CMD check (default: TRUE)",
    "#' @return Logical indicating deployment success",
    "#' @export",
    "#' @examples",
    "#' \\dontrun{",
    "#' # Deploy with default settings",
    "#' deploy_package()",
    "#'",
    "#' # Deploy with custom settings",
    "#' deploy_package(",
    "#'   repo_url = \"https://github.com/username/mypackage.git\",",
    "#'   commit_message = \"Custom update message\",",
    "#'   run_tests = TRUE,",
    "#'   run_checks = FALSE",
    "#' )",
    "#' }",
    "deploy_package <- function(repo_url = NULL, commit_message = NULL,",
    "                           run_tests = TRUE, run_checks = TRUE) {",
    "  # Load required packages",
    "  required_packages <- c(\"devtools\", \"usethis\", \"gert\", \"here\")",
    "  invisible(lapply(required_packages, function(pkg) {",
    "    if (!requireNamespace(pkg, quietly = TRUE)) {",
    "      install.packages(pkg)",
    "    }",
    "  }))",
    "",
    "  package_name <- basename(here::here())",
    "",
    "  if (is.null(repo_url)) {",
    "    repo_url <- paste0(\"https://github.com/vanhungtran/\", package_name, \".git\")",
    "  }",
    "",
    "  if (is.null(commit_message)) {",
    "    commit_message <- paste(\"Daily update for\", package_name, \"-\", Sys.Date())",
    "  }",
    "",
    "  tryCatch({",
    "    message(\"üöÄ Starting deployment for: \", package_name)",
    "    message(\"üì¶ Target repository: \", repo_url)",
    "",
    "    # Validate GitHub repo first",
    "    if (!validate_github_repo(repo_url)) {",
    "      stop(\"GitHub repository validation failed. Deployment aborted.\")",
    "    }",
    "",
    "    # Package rebuilding steps",
    "    message(\"1. üìù Cleaning and rebuilding documentation...\")",
    "    unlink(\"man\", recursive = TRUE)",
    "    dir.create(\"man\")",
    "    devtools::document()",
    "",
    "    message(\"2. üìö Rebuilding vignettes...\")",
    "    devtools::build_vignettes()",
    "",
    "    if (run_tests) {",
    "      message(\"3. üß™ Running tests...\")",
    "      test_results <- devtools::test()",
    "      if (any(as.data.frame(test_results)$failed > 0)) {",
    "        stop(\"Tests failed. Deployment aborted.\")",
    "      }",
    "    } else {",
    "      message(\"3. ‚ö†Ô∏è  Skipping tests...\")",
    "    }",
    "",
    "    if (run_checks) {",
    "      message(\"4. ‚úÖ Running package check...\")",
    "      check_results <- devtools::check(error_on = \"never\")",
    "      if (length(check_results$errors) > 0) {",
    "        stop(\"Package check failed with errors.\")",
    "      }",
    "      if (length(check_results$warnings) > 0) {",
    "        warning(\"Package check completed with warnings - review manually\")",
    "      }",
    "    } else {",
    "      message(\"4. ‚ö†Ô∏è  Skipping package check...\")",
    "    }",
    "",
    "    # Git operations",
    "    message(\"5. üîó Setting up git remote...\")",
    "    usethis::use_git_remote(\"origin\", repo_url, overwrite = TRUE)",
    "",
    "    message(\"6. üíæ Committing changes...\")",
    "",
    "    # Stage all changes",
    "    gert::git_add(\".\")",
    "",
    "    # Check if there are changes to commit",
    "    status <- gert::git_status()",
    "    if (nrow(status) == 0) {",
    "      message(\"No changes to commit.\")",
    "      return(invisible(FALSE))",
    "    }",
    "",
    "    # Commit changes",
    "    gert::git_commit(commit_message)",
    "",
    "    message(\"7. üöÄ Pushing to GitHub...\")",
    "    gert::git_push(remote = \"origin\", set_upstream = TRUE)",
    "",
    "    message(\"üéâ Deployment completed successfully!\")",
    "    message(\"üìä View your package at: \", sub(\".git$\", \"\", repo_url))",
    "    return(invisible(TRUE))",
    "",
    "  }, error = function(e) {",
    "    message(\"‚ùå Deployment failed: \", e$message)",
    "    return(invisible(FALSE))",
    "  })",
    "}",
    "",
    "#' Quick Data Summary",
    "#'",
    "#' Provides a comprehensive summary of a data frame including dimensions,",
    "#' column types, missing values, and memory usage.",
    "#'",
    "#' @param data Data frame to summarize",
    "#' @return List containing summary information",
    "#' @export",
    "#' @examples",
    "#' data_summary <- quick_summary(mtcars)",
    "#' print(data_summary$dimensions)",
    "quick_summary <- function(data) {",
    "  if (!is.data.frame(data)) {",
    "    stop(\"Input must be a data frame\")",
    "  }",
    "",
    "  list(",
    "    dimensions = dim(data),",
    "    column_names = names(data),",
    "    column_types = sapply(data, class),",
    "    missing_values = sapply(data, function(x) sum(is.na(x))),",
    "    memory_size = format(utils::object.size(data), units = \"auto\")",
    "  )",
    "}",
    "",
    "#' Safe File Reader",
    "#'",
    "#' Safely reads various file formats with comprehensive error handling",
    "#' and automatic format detection.",
    "#'",
    "#' @param file_path Path to the file",
    "#' @param type File type (auto-detected from extension if NULL)",
    "#' @param ... Additional arguments passed to read functions",
    "#' @return File contents",
    "#' @export",
    "#' @examples",
    "#' \\dontrun{",
    "#' data <- read_file_safe(\"data.csv\")",
    "#' text <- read_file_safe(\"notes.txt\")",
    "#' }",
    "read_file_safe <- function(file_path, type = NULL, ...) {",
    "  if (!file.exists(file_path)) {",
    "    stop(\"File does not exist: \", file_path)",
    "  }",
    "",
    "  if (is.null(type)) {",
    "    type <- tools::file_ext(file_path)",
    "  }",
    "",
    "  tryCatch({",
    "    switch(tolower(type),",
    "           csv = read.csv(file_path, ...),",
    "           tsv = read.delim(file_path, ...),",
    "           rds = readRDS(file_path),",
    "           txt = readLines(file_path, ...),",
    "           stop(\"Unsupported file type: \", type)",
    "    )",
    "  }, error = function(e) {",
    "    stop(\"Error reading file \", file_path, \": \", e$message)",
    "  })",
    "}"),
  "R/mestools-core.R"
)

# mestools-package.R
writeLines(
  c("#' mestools: A Collection of Useful Tools",
    "#'",
    "#' Provides utility functions for data manipulation, package development,",
    "#' and deployment automation.",
    "#'",
    "#' @docType package",
    "#' @name mestools",
    "#' @keywords internal",
    "\"_PACKAGE\"",
    "",
    "## usethis namespace: start",
    "## usethis namespace: end",
    "NULL"),
  "R/mestools-package.R"
)





# Create tests/testthat directory if it doesn't exist
if (!dir.exists("tests/testthat")) {
  dir.create("tests/testthat", recursive = TRUE)
}

# Write test-core.R
writeLines(
  c("test_that(\"validate_github_repo works with valid repo\", {",
    "  skip_on_cran()",
    "  skip_if_offline()",
    "  ",
    "  # Test with a known existing repository",
    "  result <- validate_github_repo(\"https://github.com/r-lib/usethis.git\")",
    "  expect_true(result)",
    "})",
    "",
    "test_that(\"validate_github_repo fails with invalid repo\", {",
    "  skip_on_cran()",
    "  skip_if_offline()",
    "  ",
    "  # Test with non-existent repository",
    "  result <- validate_github_repo(\"https://github.com/invalid_user/invalid_repo.git\")",
    "  expect_false(result)",
    "})",
    "",
    "test_that(\"validate_github_repo handles malformed URLs\", {",
    "  # Test with malformed URL",
    "  expect_error(validate_github_repo(\"not-a-url\"))",
    "  expect_error(validate_github_repo(NULL))",
    "  expect_error(validate_github_repo(NA))",
    "})",
    "",
    "test_that(\"quick_summary returns correct structure\", {",
    "  # Test with mtcars dataset",
    "  result <- quick_summary(mtcars)",
    "  ",
    "  expect_type(result, \"list\")",
    "  expect_named(result, c(\"dimensions\", \"column_names\", \"column_types\", ",
    "                        \"missing_values\", \"memory_size\"))",
    "  expect_equal(result$dimensions, dim(mtcars))",
    "  expect_equal(result$column_names, names(mtcars))",
    "  expect_equal(length(result$column_types), ncol(mtcars))",
    "})",
    "",
    "test_that(\"quick_summary handles edge cases\", {",
    "  # Test with empty data frame",
    "  empty_df <- data.frame()",
    "  result <- quick_summary(empty_df)",
    "  expect_equal(result$dimensions, c(0, 0))",
    "  ",
    "  # Test with non-data frame input",
    "  expect_error(quick_summary(\"not a data frame\"))",
    "  expect_error(quick_summary(123))",
    "})",
    "",
    "test_that(\"read_file_safe reads different file types\", {",
    "  # Create temporary files for testing",
    "  temp_csv <- tempfile(fileext = \".csv\")",
    "  temp_txt <- tempfile(fileext = \".txt\")",
    "  ",
    "  # Write test data",
    "  write.csv(mtcars, temp_csv, row.names = FALSE)",
    "  writeLines(c(\"line1\", \"line2\", \"line3\"), temp_txt)",
    "  ",
    "  # Test CSV reading",
    "  csv_data <- read_file_safe(temp_csv)",
    "  expect_s3_class(csv_data, \"data.frame\")",
    "  ",
    "  # Test text file reading",
    "  txt_data <- read_file_safe(temp_txt)",
    "  expect_type(txt_data, \"character\")",
    "  expect_length(txt_data, 3)",
    "  ",
    "  # Clean up",
    "  unlink(temp_csv)",
    "  unlink(temp_txt)",
    "})",
    "",
    "test_that(\"read_file_safe handles errors appropriately\", {",
    "  # Test non-existent file",
    "  expect_error(read_file_safe(\"nonexistent_file.csv\"))",
    "  ",
    "  # Test unsupported file type",
    "  expect_error(read_file_safe(\"test.unsupported\"))",
    "  ",
    "  # Create a corrupt RDS file for testing",
    "  temp_bad <- tempfile(fileext = \".rds\")",
    "  writeLines(\"not rds data\", temp_bad)",
    "  expect_error(read_file_safe(temp_bad, type = \"rds\"))",
    "  unlink(temp_bad)",
    "})"),
  "tests/testthat/test-core.R"
)

# Write test-utils.R
writeLines(
  c("test_that(\"check_dependencies works correctly\", {",
    "  # Test with existing packages",
    "  result <- check_dependencies(c(\"utils\", \"stats\"), auto_install = FALSE)",
    "  expect_true(result)",
    "  ",
    "  # Test with non-existent package (should return FALSE without auto_install)",
    "  result <- check_dependencies(\"nonexistentpackage123\", auto_install = FALSE)",
    "  expect_false(result)",
    "})",
    "",
    "test_that(\"create_project_structure creates directories\", {",
    "  # Create temporary directory for testing",
    "  temp_dir <- tempfile()",
    "  dir.create(temp_dir)",
    "  ",
    "  # Test directory creation",
    "  result <- create_project_structure(temp_dir)",
    "  expect_true(result)",
    "  ",
    "  # Check if directories were created",
    "  expected_dirs <- c(\"inputs\", \"scripts\", \"output\", \"docs\", \"ref\", \"reports\")",
    "  for (dir in expected_dirs) {",
    "    expect_true(dir.exists(file.path(temp_dir, dir)))",
    "  }",
    "  ",
    "  # Clean up",
    "  unlink(temp_dir, recursive = TRUE)",
    "})",
    "",
    "test_that(\"create_project_structure handles existing directories\", {",
    "  temp_dir <- tempfile()",
    "  dir.create(temp_dir)",
    "  ",
    "  # Create one directory in advance",
    "  dir.create(file.path(temp_dir, \"inputs\"))",
    "  ",
    "  # Should still work without errors",
    "  expect_silent(create_project_structure(temp_dir))",
    "  ",
    "  unlink(temp_dir, recursive = TRUE)",
    "})",
    "",
    "test_that(\"batch_apply processes objects correctly\", {",
    "  # Test with simple function",
    "  numbers <- 1:5",
    "  results <- batch_apply(numbers, function(x) x^2, .progress = FALSE)",
    "  ",
    "  expect_type(results, \"list\")",
    "  expect_length(results, 5)",
    "  expect_equal(results[[1]], 1)",
    "  expect_equal(results[[3]], 9)",
    "  ",
    "  # Test with function that throws errors",
    "  results_with_errors <- batch_apply(",
    "    c(1, \"not_number\", 3), ",
    "    function(x) as.numeric(x)^2, ",
    "    .progress = FALSE",
    "  )",
    "  expect_true(is.null(results_with_errors[[2]]))",
    "})",
    "",
    "test_that(\"generate_random_df creates correct structure\", {",
    "  # Test default parameters",
    "  df <- generate_random_df()",
    "  expect_equal(dim(df), c(100, 5))",
    "  expect_s3_class(df, \"data.frame\")",
    "  ",
    "  # Test custom parameters",
    "  df_custom <- generate_random_df(n_rows = 10, n_cols = 3)",
    "  expect_equal(dim(df_custom), c(10, 3))",
    "  ",
    "  # Test reproducibility with seed",
    "  df1 <- generate_random_df(5, 2, seed = 123)",
    "  df2 <- generate_random_df(5, 2, seed = 123)",
    "  expect_identical(df1, df2)",
    "  ",
    "  # Test different seed produces different results",
    "  df3 <- generate_random_df(5, 2, seed = 456)",
    "  expect_false(identical(df1, df3))",
    "})"),
  "tests/testthat/test-utils.R"
)

# Write test-deployment.R
writeLines(
  c("test_that(\"deploy_package validates inputs correctly\", {",
    "  # Test with invalid repository URL",
    "  expect_error(",
    "    deploy_package(repo_url = \"invalid-url\"),",
    "    \"GitHub repository validation failed\"",
    "  )",
    "})",
    "",
    "test_that(\"deploy_package handles missing dependencies\", {",
    "  # Mock the situation where required packages are missing",
    "  with_mocked_bindings(",
    "    .package = \"base\",",
    "    requireNamespace = function(pkg, ...) FALSE,",
    "    {",
    "      expect_error(deploy_package(run_tests = FALSE, run_checks = FALSE))",
    "    }",
    "  )",
    "})",
    "",
    "test_that(\"deploy_package generates correct commit message\", {",
    "  # Test auto-generated commit message",
    "  with_mocked_bindings(",
    "    .package = \"mestools\",",
    "    validate_github_repo = function(...) TRUE,",
    "    devtools::document = function() NULL,",
    "    devtools::build_vignettes = function() NULL,",
    "    devtools::test = function() list(failed = 0),",
    "    devtools::check = function(...) list(errors = character(0), warnings = character(0)),",
    "    usethis::use_git_remote = function(...) NULL,",
    "    gert::git_add = function(...) NULL,",
    "    gert::git_status = function() data.frame(file = \"test.R\", status = \"modified\"),",
    "    gert::git_commit = function(message, ...) {",
    "      expect_true(grepl(\"Daily update\", message))",
    "      expect_true(grepl(Sys.Date(), message))",
    "    },",
    "    gert::git_push = function(...) NULL,",
    "    {",
    "      # This will test the commit message generation",
    "      result <- deploy_package(run_tests = FALSE, run_checks = FALSE)",
    "      expect_false(result) # Because we're mocking and not actually committing",
    "    }",
    "  )",
    "})"),
  "tests/testthat/test-deployment.R"
)

# Write test-package.R
writeLines(
  c("test_that(\"package loads correctly\", {",
    "  # Test that the package can be loaded",
    "  expect_silent(library(mestools))",
    "  expect_true(\"mestools\" %in% loadedNamespaces())",
    "})",
    "",
    "test_that(\"all exported functions are available\", {",
    "  # Check that expected functions are exported",
    "  expected_functions <- c(",
    "    \"validate_github_repo\",",
    "    \"deploy_package\", ",
    "    \"quick_summary\",",
    "    \"read_file_safe\",",
    "    \"check_dependencies\",",
    "    \"create_project_structure\",",
    "    \"batch_apply\",",
    "    \"generate_random_df\"",
    "  )",
    "  ",
    "  for (func in expected_functions) {",
    "    expect_true(exists(func, where = asNamespace(\"mestools\"), mode = \"function\"),",
    "                info = paste(\"Function\", func, \"should be exported\"))",
    "  }",
    "})",
    "",
    "test_that(\"package documentation exists\", {",
    "  # Check that package documentation is available",
    "  expect_true(!is.null(utils::packageDescription(\"mestools\")))",
    "})"),
  "tests/testthat/test-package.R"
)

# Write tests/testthat.R
writeLines(
  c("library(testthat)",
    "library(mestools)",
    "",
    "test_check(\"mestools\")"),
  "tests/testthat.R"
)

# Write tests/testthat/setup.R (optional setup)
writeLines(
  c("# Setup code that runs before tests",
    "library(testthat)",
    "library(mestools)",
    "",
    "# Set test-specific options",
    "options(mestools.test_mode = TRUE)",
    "",
    "# Create a temporary directory for file operations",
    "test_temp_dir <- tempfile()",
    "dir.create(test_temp_dir)",
    "",
    "# Cleanup function that runs after tests",
    "withr::defer({",
    "  unlink(test_temp_dir, recursive = TRUE)",
    "}, teardown_env())"),
  "tests/testthat/setup.R"
)

# Write tests/testthat/teardown.R (optional teardown)
writeLines(
  c("# Teardown code that runs after tests",
    "if (exists(\"test_temp_dir\") && dir.exists(test_temp_dir)) {",
    "  unlink(test_temp_dir, recursive = TRUE)",
    "}",
    "",
    "# Reset any modified options",
    "options(mestools.test_mode = NULL)"),
  "tests/testthat/teardown.R"
)



